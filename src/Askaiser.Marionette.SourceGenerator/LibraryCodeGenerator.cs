using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using Microsoft.CodeAnalysis;

namespace Askaiser.Marionette.SourceGenerator;

public class LibraryCodeGenerator
{
    private static readonly HashSet<string> SupportedImageExtensions = new(StringComparer.OrdinalIgnoreCase)
    {
        ".PNG", ".JPEG", ".JPG", ".BMP",
    };

    private readonly IFileSystem _fileSystem;
    private readonly IDateTimeProvider _dateTimeProvider;
    private readonly TargetedClassInfo _target;
    private readonly GeneratedLibrary _rootLibrary;
    private readonly List<Diagnostic> _diagnostics;

    internal LibraryCodeGenerator(IFileSystem fileSystem, IDateTimeProvider dateTimeProvider, TargetedClassInfo target)
    {
        this._fileSystem = fileSystem;
        this._dateTimeProvider = dateTimeProvider;
        this._target = target;
        this._rootLibrary = new GeneratedLibrary("root");
        this._diagnostics = new List<Diagnostic>();
    }

    public CodeGeneratorResult Generate()
    {
        this.ProcessImagesInDirectory(this._target.ImageDirectoryPath, this._rootLibrary);
        var filename = $"{this._target.NamespaceName}.{this._target.ClassName}.images.cs".TrimStart('.');
        return new CodeGeneratorResult(filename, this.GenerateCode(), this._diagnostics);
    }

    private void ProcessImagesInDirectory(string directoryPath, GeneratedLibrary library)
    {
        var imageFiles = this._fileSystem.EnumerateFiles(directoryPath).Where(EndsWithImageExtension);

        this.ProcessImages(imageFiles, library);

        foreach (var subDirectoryPath in this._fileSystem.EnumerateDirectories(directoryPath))
        {
            var localLibraryRef = library;
            var subLibrary = library.Libraries.GetOrCreate(Path.GetFileName(subDirectoryPath), x => localLibraryRef.CreateChild(x));
            this.ProcessImagesInDirectory(subDirectoryPath, subLibrary);
        }
    }

    private static bool EndsWithImageExtension(string path)
    {
        return SupportedImageExtensions.Any(x => path.EndsWith(x, StringComparison.OrdinalIgnoreCase));
    }

    private void ProcessImages(IEnumerable<string> imageFilePaths, GeneratedLibrary library)
    {
        foreach (var imageFilePath in imageFilePaths)
        {
            this.ProcessImage(imageFilePath, library);
        }
    }

    private void ProcessImage(string imageFilePath, GeneratedLibrary library)
    {
        GeneratedImage image;

        try
        {
            var imageFileSize = this._fileSystem.GetFileSize(imageFilePath);
            if (imageFileSize > this._target.MaxImageSize)
            {
                this._diagnostics.Add(Diagnostic.Create(DiagnosticsDescriptors.FileTooLarge, this._target.SyntaxNode.GetLocation(), imageFilePath, this._target.MaxImageSize.ToString(CultureInfo.InvariantCulture)));
                return;
            }

            if (imageFileSize == 0)
            {
                return;
            }

            var bytes = this._fileSystem.GetFileBytes(imageFilePath);
            image = new GeneratedImage(Path.GetFileName(imageFilePath), bytes, library);
        }
        catch (Exception ex)
        {
            this._diagnostics.Add(Diagnostic.Create(DiagnosticsDescriptors.UnexpectedException, this._target.SyntaxNode.GetLocation(), ex.ToString()));
            return;
        }

        var imageGroup = image.Parent.Images.GetOrCreate(image.Name, _ => new List<GeneratedImage>());

        if (imageGroup.Any(x => x.GroupIndex == image.GroupIndex))
        {
            this._diagnostics.Add(Diagnostic.Create(DiagnosticsDescriptors.DuplicateImageName, this._target.SyntaxNode.GetLocation(), image.UniqueName, imageFilePath));
        }
        else
        {
            imageGroup.Add(image);
        }
    }

    private string GenerateCode()
    {
        var cw = new CodeWriter();

        cw.Append("// Code generated at ").AppendLine(this._dateTimeProvider.Now.ToString("O"));
        cw.Append("// From directory: ").AppendLine(this._target.ImageDirectoryPath);
        cw.AppendLine("// <auto-generated/>");
        cw.AppendLine("#nullable enable");
        cw.AppendLine();

        IDisposable? namespaceBlock = null;
        try
        {
            if (!string.IsNullOrWhiteSpace(this._target.NamespaceName))
            {
                namespaceBlock = cw.BeginNamespace(this._target.NamespaceName);
            }

            this.GenerateLibraryCode(this._rootLibrary, cw);
        }
        finally
        {
            namespaceBlock?.Dispose();
        }

        return cw.ToString();
    }

    private void GenerateLibraryCode(GeneratedLibrary library, CodeWriter cw)
    {
        var className = library.IsRoot ? this._target.ClassName : library.UniqueName + "Library";

        if (!library.IsRoot)
        {
            cw.AppendLine();
        }

        using (cw.BeginClass(this._target.ModifierNames, className))
        {
            cw.AppendGeneratedCodeAttributeLine();
            cw.AppendLine("private readonly global::Askaiser.Marionette.ElementCollection _elements;");
            cw.AppendLine();

            if (library.IsRoot)
            {
                cw.AppendGeneratedCodeAttributeLine();
                cw.Append("private static readonly global::System.Lazy<").Append(className).Append("> _instance = new global::System.Lazy<").Append(className).Append(">(() => new ").Append(className).AppendLine("());");
                cw.AppendLine();

                cw.AppendGeneratedCodeAttributeLine();
                cw.Append("public static ").Append(className).AppendLine(" Instance");

                using (cw.BeginBlock())
                {
                    cw.AppendLine("get { return _instance.Value; }");
                }

                cw.AppendLine();
            }

            this.GenerateLibraryConstructorCode(library, cw);
            GenerateLibraryPropertiesCode(library, cw);
            GenerateLibraryElementCreationCode(library, cw);
        }

        foreach (var childLibrary in library.Libraries.Values.Where(x => !x.IsEmpty).OrderBy(x => x.UniqueName, StringComparer.OrdinalIgnoreCase))
        {
            this.GenerateLibraryCode(childLibrary, cw);
        }
    }

    private void GenerateLibraryConstructorCode(GeneratedLibrary library, CodeWriter cw)
    {
        cw.AppendGeneratedCodeAttributeLine();

        if (library.IsRoot)
        {
            cw.Append("public ").Append(this._target.ClassName).AppendLine("()");
        }
        else
        {
            cw.Append("public ").Append(library.UniqueName).Append("Library").AppendLine("(global::Askaiser.Marionette.ElementCollection elements)");
        }

        using (cw.BeginBlock())
        {
            cw.AppendLine(library.IsRoot ? "this._elements = new global::Askaiser.Marionette.ElementCollection();" : "this._elements = elements;");

            foreach (var childLibrary in library.Libraries.Values.Where(x => !x.IsEmpty).OrderBy(x => x.UniqueName, StringComparer.OrdinalIgnoreCase))
            {
                cw.Append("this.").Append(childLibrary.Name).Append(" = new ").Append(childLibrary.UniqueName).AppendLine("Library(this._elements);");
            }

            if (library.IsRoot)
            {
                if (library.Libraries.Count > 0)
                {
                    cw.AppendLine();
                }

                cw.AppendLine("this.CreateElements();");
            }
        }
    }

    private static void GenerateLibraryPropertiesCode(GeneratedLibrary library, CodeWriter cw)
    {
        foreach (var childLibrary in library.Libraries.Values.Where(x => !x.IsEmpty).OrderBy(x => x.UniqueName, StringComparer.OrdinalIgnoreCase))
        {
            cw.AppendLine();
            cw.AppendGeneratedCodeAttributeLine();
            cw.Append("public ").Append(childLibrary.UniqueName).Append("Library ").Append(childLibrary.Name).AppendLine(" { get; }");
        }

        foreach (var imageGroup in library.Images.Values)
        {
            cw.AppendLine();

            cw.AppendGeneratedCodeAttributeLine();

            if (imageGroup.Count == 1)
            {
                cw.Append("public global::Askaiser.Marionette.IElement ").Append(imageGroup[0].Name).Append(" => this._elements[\"").Append(imageGroup[0].UniqueName).AppendLine("\"];");
            }
            else
            {
                cw.Append("public global::Askaiser.Marionette.IElement[] ").Append(imageGroup[0].Name).AppendLine(" => new[]");
                cw.AppendLine("{");

                for (var j = 0; j < imageGroup.Count; j++)
                {
                    cw.Append("    this._elements[\"").Append(imageGroup[j].UniqueName).AppendLine(j == imageGroup.Count - 1 ? "\"]" : "\"],");
                }

                cw.AppendLine("};");
            }
        }
    }

    private static void GenerateLibraryElementCreationCode(GeneratedLibrary library, CodeWriter cw)
    {
        if (library.Level > 0)
        {
            return;
        }

        cw.AppendLine();
        cw.AppendGeneratedCodeAttributeLine();
        cw.AppendLine("private void CreateElements()");
        using (cw.BeginBlock())
        {
            foreach (var image in library.GetImagesChildren().OrderBy(x => x.UniqueName, StringComparer.OrdinalIgnoreCase))
            {
                cw.Append("this._elements.Add(new global::Askaiser.Marionette.ImageElement(\"")
                    .Append(image.UniqueName)
                    .Append("\", \"")
                    .Append(Convert.ToBase64String(image.Bytes))
                    .Append("\", ")
                    .Append(image.Threshold.ToString(CultureInfo.InvariantCulture))
                    .Append("m, ").Append(image.Grayscale ? "true" : "false")
                    .AppendLine("));");
            }
        }
    }
}
